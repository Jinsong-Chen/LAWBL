---
title: "gpcfa-examples"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{gpcfa-examples}
  %\VignetteEncoding{UTF-8}
  <!-- \usepackage[utf8]{inputenc} -->
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#R"
)
```

**Note: the estimation process can be time consuming depending on the computing power. You can same some time by reducing the length of the chains.**

## Categorical Data with Missingness but no Local Dependence:

1) Load the package, obtain the data, loading pattern (*qlam*), and setup the design matrix Q.

```{r}
library(LAWBL)
dat <- sim18ccfa40$dat
head(dat) #10% missingness at random
J <- ncol(dat) # no. of items
K <- 3 # no. of factors
qlam <- sim18ccfa40$qlam
qlam

Q<-matrix(-1,J,K); # -1 for unspecified items
Q[1:2,1]<-Q[7:8,2]<-Q[13:14,3]<-1 # 1 for specified items
Q
```

2) **E-step:** Estimate with the GPCFA-LI model (E-step) by setting *LD=F*. Only a few loadings need to be specified in Q (e.g., 2 per factor). Longer chain is suggested for stabler performance (*burn=iter=5,000* by default).


```{r}
m0 <- pcfa(dat = dat, Q = Q,LD = FALSE, cati = -1,burn = 2000, iter = 2000,verbose = TRUE)

# summarize basic information
summary(m0)

#summarize significant loadings in pattern/Q-matrix format
summary(m0, what = 'qlambda') 

#factorial eigenvalue
summary(m0,what='eigen') 

#thresholds for categorical items
summary(m0,what='thd')

#plotting factorial eigenvalue
plot_eigen(m0) # trace
plot_eigen(m0, what='density') #density
plot_eigen(m0, what='APSR') #adj, PSRF
```

3) **C-step:** Reconfigure the Q matrix for the C-step with one specified loading per item based on results from the E-step. Estimate with the GPCFA model by setting *LD=TRUE* (by default). Longer chain is suggested for stabler performance. Results are very close to the E-step, since there's no LD in the data.

```{r eval=FALSE}
Q<-matrix(-1,J,K);
tmp<-summary(m0, what="qlambda")
cind<-apply(tmp,1,which.max)
Q[cbind(c(1:J),cind)]<-1
#alternatively
#Q[1:6,1]<-Q[7:12,2]<-Q[13:18,3]<-1 # 1 for specified items

m1 <- pcfa(dat = dat, Q = Q, cati = -1,burn = 2000, iter = 2000,verbose = TRUE)
summary(m1)
summary(m1, what = 'qlambda')
summary(m1, what = 'offpsx') #summarize significant LD terms
summary(m1,what='eigen')
summary(m1,what='thd')

#plotting factorial eigenvalue
# par(mar = rep(2, 4))
plot_eigen(m1) # trace
plot_eigen(m1, what='density') #density
plot_eigen(m1, what='APSR') #adj, PSRF
```

4) **CFA-LD:** One can also configure the Q matrix for a CCFA model with local dependence (i.e. without any unspecified loading) based on results from the C-step. Results are also very close.

```{r eval=FALSE}
Q<-summary(m1, what="qlambda")
Q[Q!=0]<-1
Q

m2 <- pcfa(dat = dat, Q = Q, cati = -1,burn = 2000, iter = 2000,verbose = TRUE)
summary(m2)
summary(m2, what = 'qlambda') 
summary(m2, what = 'offpsx')
summary(m2,what='eigen')
summary(m2,what='thd')

plot_eigen(m2) # Eigens' traces are excellent without regularization of the loadings
```

## Categorical Data with Local Dependence:

1) Load the the data, loading pattern (*qlam*), and LD terms, and setup the design matrix Q.

```{r, eval=FALSE}
dat <- sim18ccfa41$dat
head(dat)
J <- ncol(dat) # no. of items
K <- 3 # no. of factors
sim18ccfa41$qlam
sim18ccfa41$LD # effect size = .3

Q<-matrix(-1,J,K); # -1 for unspecified items
Q[1:2,1]<-Q[7:8,2]<-Q[13:14,3]<-1 # 1 for specified items
Q

```

2) **E-step:** Estimate with the GPCFA-LI model (E-step) by setting *LD=FALSE*. Only a few loadings need to be specified in Q (e.g., 2 per factor). Some loading estimates are biased due to ignoring the LD. So do the eigenvalues.

```{r eval=FALSE}
m0 <- pcfa(dat = dat, Q = Q,LD = FALSE, cati = -1,burn = 4000, iter = 4000,verbose = TRUE)
summary(m0)
summary(m0, what = 'qlambda')
summary(m0,what='eigen')
summary(m0,what='thd')

plot_eigen(m0) # trace
plot_eigen(m0, what='APSR')
```

3) **C-step:** Reconfigure the Q matrix for the C-step with one specified loading per item based on results from the E-step. Estimate with the GPCFA model by setting *LD=TRUE* (by default). The estimates are more accurate, and the LD terms can be largely recovered.

```{r eval=FALSE}
Q<-matrix(-1,J,K);
tmp<-summary(m0, what="qlambda")
cind<-apply(tmp,1,which.max)
Q[cbind(c(1:J),cind)]<-1
Q

m1 <- pcfa(dat = dat, Q = Q, cati = -1,burn = 4000, iter = 4000,verbose = TRUE)
summary(m1)
summary(m1, what = 'qlambda')
summary(m1,what='eigen')
summary(m1, what = 'offpsx')
summary(m1,what='thd')
```

4) **CFA-LD:** Configure the Q matrix for a CCFA model with local dependence (i.e. without any unspecified loading) based on results from the C-step. Results are better than, but similar to the C-step.

```{r eval=FALSE}
Q<-summary(m1, what="qlambda")
Q[Q!=0]<-1
Q

m2 <- pcfa(dat = dat, Q = Q, cati = -1,burn = 4000, iter = 4000,verbose = TRUE)
summary(m2)
summary(m2, what = 'qlambda') 
summary(m2,what='eigen')
summary(m2, what = 'offpsx')
summary(m2,what='thd')
```
