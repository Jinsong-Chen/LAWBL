---
title: "LAWBL-Vignettes"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{LAWBL-Vignettes}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

**Note: the estimation process can be time consuming depending on the computing power. You can same some time by reducing the length of the chains.**

## Data with Local Independence:

1) Load the package, obtain the data, loading pattern (*qlam*), and setup the design matrix Q.

```{r, eval=FALSE}
library(LAWBL)
dat <- sim18cfa0$dat
J <- ncol(dat) # no. of items
K <- 3 # no. of factors
qlam <- sim18cfa0$qlam
qlam

Q<-matrix(-1,J,K); # -1 for unspecified items
Q[1:2,1]<-Q[7:8,2]<-Q[13:14,3]<-1 # 1 for specified items
Q
```

2) **E-step:** Estimate with the PCFA-LI model (E-step) by setting *LD=F*. Only a few loadings need to be specified in Q (e.g., 2 per factor). Longer chain is suggested for stabler performance (*burn=iter=5,000* by default). Note the sampling information is updated every 1000 draws by default, with *Feigen* for factorial eigenvalue, "*NLA_ns3*" for no. of $\lambda$ not smaller than .3, *Shrink* for shrinkage, and *Adj PSR* for adjusted PSRF. Estimates are close to the true values.


```{r eval=FALSE}

mod0 <- pcfa(dat = dat, Q = Q,LD = F, burn = 10000, iter = 10000)
summary(mod0) # summarize basic information
summary(mod0, what = 'qlambda') #summarize significant loadings in pattern/Q-matrix format
summary(mod0,what='eigen') #factorial eigenvalue

plot_eigen(mod0) # trace
plot_eigen(mod0, what='density')
plot_eigen(mod0, what='APSR')
```

3) **C-step:** Reconfigure the Q matrix for the C-step with one specified loading per item based on results from the E-step. Estimate with the PCFA model by setting *LD=T*. Longer chain is suggested for stabler performance. *LD>=.2 >=.1* are no. of LD terms not smaller than .2 and .1. Results are very close to the E-step, since there's no LD in the data.

```{r eval=FALSE}
Q<-matrix(-1,J,K);
tmp<-summary(mod0, what="qlambda")
cind<-apply(tmp,1,which.max)
Q[cbind(c(1:J),cind)]<-1
#alternatively
#Q[1:6,1]<-Q[7:12,2]<-Q[13:18,3]<-1 # 1 for specified items

mod1 <- pcfa(dat = dat, Q = Q,LD = T, burn = 10000, iter = 10000)
summary(mod1)
summary(mod1, what = 'qlambda')
summary(mod1, what = 'offpsx') #summarize significant LD terms
summary(mod1,what='eigen')
```

4) **CFA-LD:** One can also configure the Q matrix for a CFA model with local dependence (i.e. without any unspecified loading) based on results from the C-step. Results are also very close.

```{r eval=FALSE}
Q<-summary(mod1, what="qlambda")
Q[Q!=0]<-1
Q

mod2 <- pcfa(dat = dat, Q = Q,LD = T, burn = 10000, iter = 10000)
summary(mod2)
summary(mod2, what = 'qlambda') 
summary(mod2, what = 'offpsx')
summary(mod2,what='eigen')

plot_eigen(mod2) # Eigens' traces are excellent without regulazation of the loadings
```

## Data with Local Dependence:

1) Load the the data, loading pattern (*qlam*), and LD terms, and setup the design matrix Q.

```{r, eval=FALSE}
dat <- sim18cfa1$dat
J <- ncol(dat) # no. of items
K <- 3 # no. of factors
sim18cfa1$qlam
sim18cfa1$LD # effect size = .3

Q<-matrix(-1,J,K); # -1 for unspecified items
Q[1:2,1]<-Q[7:8,2]<-Q[13:14,3]<-1 # 1 for specified items
Q

```

2) **E-step:** Estimate with the PCFA-LI model (E-step) by setting *LD=F*. Only a few loadings need to be specified in Q (e.g., 2 per factor). Some loading estimates are biased due to ignoring the LD. So do the eigenvalues.

```{r eval=FALSE}
mod0 <- pcfa(dat = dat, Q = Q,LD = F, burn = 10000, iter = 10000)
summary(mod0)
summary(mod0, what = 'qlambda')
summary(mod0,what='eigen')
```

3) **C-step:** Reconfigure the Q matrix for the C-step with one specified loading per item based on results from the E-step. Estimate with the PCFA model by setting *LD=T*. The estimates are more accurate, and the LD terms can be largely recovered.

```{r eval=FALSE}
Q<-matrix(-1,J,K);
tmp<-summary(mod0, what="qlambda")
cind<-apply(tmp,1,which.max)
Q[cbind(c(1:J),cind)]<-1
Q

mod1 <- pcfa(dat = dat, Q = Q,LD = T, burn = 10000, iter = 10000)
summary(mod1)
summary(mod1, what = 'qlambda')
summary(mod1,what='eigen')
summary(mod1, what = 'offpsx')

```

4) **CFA-LD:** Configure the Q matrix for a CFA model with local dependence (i.e. without any unspecified loading) based on results from the C-step. Results are better than, but similar to the C-step.

```{r eval=FALSE}
Q<-summary(mod1, what="qlambda")
Q[Q!=0]<-1
Q

mod2 <- pcfa(dat = dat, Q = Q,LD = T, burn = 10000, iter = 10000)
summary(mod2)
summary(mod2, what = 'qlambda') 
summary(mod2,what='eigen')
summary(mod2, what = 'offpsx')
```
